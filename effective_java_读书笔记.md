## 第一章:基本原则
1. 清晰性和简洁性最为重要
2. 代码应该被重用, 而不是拷贝
3. 错误应该尽早被检测出来, 最好是在编译时刻
4. 模块之间的依赖性尽可能地降到最小; 模块是指任何可被重用的组件, 从单个方法, 到包含多个包的复杂系统



## 第二章: 创建和销毁对象
**使用静态工厂方法替换构造器**
1. 因为是方法, 所以可以起一个清晰的名字, 以便突出他们的区别
2. 每次调用返回相同的对象. 避免重复创建; 例如Boolean
3. 可以使用参数type, 利用多态从而返回不同的接口子类型

**多个参数时要考虑用构建器**
1. 有可能有多个参数一开始就使用builder, 有更好的扩展性

 **私有构造器强化不可实例化的能力使用枚举**
1. 枚举是最佳方式实现单例方式

**避免创建不必要的对象**
1. 如果对象是不可变的, 他就始终可以被重用
2. 还可以重用那些已知不会被修改的可变对象
3. 有时重用对象的代价远远大于创建对象, 谨慎的重用对象,小心潜在的错误,  对于重量级的对象, 可以复用;

**消除过期的引用对象**
1. 如果一个对象被无意识的保留下来, 垃圾回收机制不仅不会处理这个对象, 而且该对象引用的对象也不会被处理
2. 当你的缓存key其生命周期由外部引用而不是value值决定时, 可以使用WeakHashMap, 它能自动清除过期的项;weakreference

## 第三章: 对于所有对象都通用的方法

**覆盖equals**
1. 不覆盖equals方法, 类的每个实例都和他自身相等
2. 覆盖equals后, 他必须满足以下要求: 
	1. 自反性: 他必须equals自己
		2. 对称性: x.equals(y) y.equals(x)
		3. 传递性: x.equals(y) y.equals(z) x.equals(z)
		4. 一致性: 多次调用x.equals(y)都返回true

## 第四章: 类和接口
**可访问性最小化**
1. 封装: 隐藏所有实现细节, 模块之间只通过接口进行通信;
2. 加快开发速度, 并行开发; 方便调试性能; 提高了重用性, 降低了构建的风险
3. 尽可能的降低访问级别

**不可变类**
4. 不要暴露可变域
5. 使类不可变: 该类的所有信息都必须在创建时确定, 并且对象的整个生命周期都不会改变
	1. 不要提供任何修改对象状态的方法
	2. 保证类不会被扩展
	3. 使所有的域都是final
	4. 使所有的域都是私有的
	5. 确保可变的域, 客户端无法获得指向的引用; 也不要使用客户端提供的对象引用这样的域, 也不要任何方法直接返回这样的域; 参考使用保护性拷贝
6. 不可变对象只有一种状态就是创建时的状态
7. 不可变对象是线程安全的, 可以自由共享, 可以使用静态工厂复用这样对象, 无需做保护性拷贝
8. 不可变对象可以缓存一个计算昂贵的非final域, 因为不可变性保证了, 再次计算这个域也会得到同样的结果
9. 如果类无法做成不可变的, 仍然应该尽可能的限制他的可变性, 降低存在的状态数, 更容易的分析对象的行为

**复合优于继承**
1. 在包的内部继承是安全的, 父类和子类的实现在一个程序员控制之下
2. 继承打破了封装性, 父类的实现发生变化, 子类必须要跟着其父类更新而演变
3. 在新类增加一个实例, 它引用现有的类一个实例, 这称作复合; 新类中的方法调用被包含现有类实例中对应的方法, 并返回结果, 这称作转发;
4. 当存在适当的接口实现包装类时, 包装类比子类更加强健, 功能也更加强大和灵活;
Set\<Date\> set = new InstrumentedSet(new TreeSet\<Date\>(cmp));   
Set\<T\> set2 = new InstrumentedSet(new HashSet\<T\>(cmp)); 

5. 父类的构造方法决不能调用可被覆盖的方法, 无论是直接调用还是间接调用; 因为父类的构造方法在子类的构造方法之前运行, 如果此覆盖方法依赖于子类的构造方法的初始化工作, 可能会发生NullPointerException 









