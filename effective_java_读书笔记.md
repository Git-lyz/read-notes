## 第一章:基本原则
1. 清晰性和简洁性最为重要
2. 代码应该被重用, 而不是拷贝
3. 错误应该尽早被检测出来, 最好是在编译时刻
4. 模块之间的依赖性尽可能地降到最小; 模块是指任何可被重用的组件, 从单个方法, 到包含多个包的复杂系统



## 第二章: 创建和销毁对象
**使用静态工厂方法替换构造器**
1. 因为是方法, 所以可以起一个清晰的名字, 以便突出他们的区别
2. 每次调用返回相同的对象. 避免重复创建; 例如Boolean
3. 可以使用参数type, 利用多态从而返回不同的接口子类型

**多个参数时要考虑用构建器**
1. 有可能有多个参数一开始就使用builder, 有更好的扩展性

 **私有构造器强化不可实例化的能力使用枚举**
1. 枚举是最佳方式实现单例方式

**避免创建不必要的对象**
1. 如果对象是不可变的, 他就始终可以被重用
2. 还可以重用那些已知不会被修改的可变对象
3. 有时重用对象的代价远远大于创建对象, 谨慎的重用对象,小心潜在的错误,  对于重量级的对象, 可以复用;

**消除过期的引用对象**
1. 如果一个对象被无意识的保留下来, 垃圾回收机制不仅不会处理这个对象, 而且该对象引用的对象也不会被处理
2. 当你的缓存key其生命周期由外部引用而不是value值决定时, 可以使用WeakHashMap, 它能自动清除过期的项;weakreference

## 第三章: 对于所有对象都通用的方法

**覆盖equals**
1. 不覆盖equals方法, 类的每个实例都和他自身相等
2. 覆盖equals后, 他必须满足以下要求: 
	1. 自反性: 他必须equals自己
		2. 对称性: x.equals(y) y.equals(x)
		3. 传递性: x.equals(y) y.equals(z) x.equals(z)
		4. 一致性: 多次调用x.equals(y)都返回true

## 第四章: 类和接口
**可访问性最小化**
1. 封装: 隐藏所有实现细节, 模块之间只通过接口进行通信;
2. 加快开发速度, 并行开发; 方便调试性能; 提高了重用性, 降低了构建的风险
3. 尽可能的降低访问级别
